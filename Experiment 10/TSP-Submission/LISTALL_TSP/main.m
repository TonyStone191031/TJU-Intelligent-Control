% 穷举法计算最短路径和最短距离
clear

% X =[117.00, 36.68     % 山东
%     115.48, 38.03     % 河北
%     125.35, 43.88     % 吉林
%     127.63, 47.75     % 黑龙江
%     123.38, 41.80     % 辽宁
%     111.67, 41.82     % 内蒙古
%     87.68,  43.77     % 新疆
%     103.73, 36.03     % 甘肃
%     106.27, 37.47     % 宁夏
%     112.53, 37.87     % 山西
%     108.95, 34.27     % 陕西
%     113.65, 34.77     % 河南
%     117.28, 31.86     % 安徽
%     119.78, 32.05     % 江苏
%     120.20, 30.27     % 浙江
%     118.30, 26.08     % 福建
%     113.23, 23.17     % 广东
%     115.90, 28.68     % 江西
%     110.35, 20.02     % 海南
%     108.32, 22.82     % 广西
%     106.72, 26.57     % 贵州
%     113.00, 28.22     % 湖南
%     114.30, 30.58     % 湖北
%     104.07, 30.67     % 四川
%     102.73, 25.05     % 云南
%     91.00,  30.60     % 西藏
%     96.75,  36.57     % 青海
%     117.20, 39.13     % 天津
%     121.55, 31.20     % 上海
%     106.45, 29.57     % 重庆
%     116.42, 39.92     % 北京
%     121.30, 25.03     % 台湾
%     114.10, 22.20     % 香港
%     113.50, 22.20];   % 澳门

% 由于MATLAB函数perms限制最多进行10个元素的全排列
% 因此X保留前10行

X =[117.00, 36.68     % 山东
    115.48, 38.03     % 河北
    125.35, 43.88     % 吉林
    127.63, 47.75     % 黑龙江
    123.38, 41.80     % 辽宁
    111.67, 41.82     % 内蒙古
    87.68,  43.77     % 新疆
    103.73, 36.03     % 甘肃
    106.27, 37.47     % 宁夏
    112.53, 37.87];   % 山西

D = Distance(X);  % 生成距离矩阵
N = size(D,1);    % (10*10)

% list是行向量，其中是1到N总共N个自然数从小到大的顺序排列
list = zeros(1,N);  % 初始化list
for i = 1:N
    list(i) = i;
end
full_perm = perms(list);    % perms对list进行全排列
num_full_perm = size(full_perm, 1); % list的全排列个数

dis = 0;
shortest_dis = 0;   % 最短距离
shortest_route = 0; % 最短路径

% 穷举
for i = 1 : num_full_perm
    dis = 0;
    for j = 1 : N
        k = full_perm(i,j);
        if j == N
            k_next = full_perm(i,1);
        else
            k_next = full_perm(i,j+1);
        end
        dis = D(k,k_next) + dis;
    end
    if i == 1
        shortest_dis = dis;
        shortest_route = full_perm(i,:);
    else
        if shortest_dis > dis
            shortest_dis = dis;
            shortest_route = full_perm(i,:);
        end
    end
end

disp('穷举结束');
OutputPath(shortest_route);
disp(['总距离：',num2str(shortest_dis)]);
